#!/usr/bin/env python3

"""
    archimedes, splatte.dev's port forwarding daemon
    Copyright (C) 2026-2027 splatte.dev

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import json
import os
import subprocess
import threading
import time
import signal

COMMANDS = {}
ALIVE = True

def port_forward_command(remote, local, host):
    return [
        "ssh",
        "-N",
        "-o",
        "ServerAliveInterval=60",
        "-o",
        "ServerAliveCountMax=1",
        "-L",
        f"{local}:localhost:{remote}",
        host,
    ]

def load_configuration():
    with open("/etc/uber.json", "r") as f:
        config = json.load(f)

    for service, metadata in config.items():
        host, remote, local = metadata[0], metadata[1], metadata[2]
        COMMANDS[service] = port_forward_command(remote, local, host)

    print("Successfully read configuration file...")

def connection_listener(service, command):
    while ALIVE:
        proc = subprocess.Popen(
            command,
        )
        print(f"Connected to {service}...")

        proc.wait()

        print(f"Connection for {service} died... Sleeping for 5 seconds then reconnecting.")
        time.sleep(5)

    print(f"No longer listening to {service}...")

def main():
    print("Archimedes online...")

    load_configuration()

    for service, command in COMMANDS.items():
        thread = threading.Thread(target=connection_listener, args=(service, command))
        thread.start()

    if not ALIVE:
        return;

def handle_signal(signum, _):
    global ALIVE

    print(f"Recieved signal {signum}. Gracefully shutting down...")
    ALIVE = False
    print("Killing all SSH processes...")
    os.system("killall ssh")
    return

signal.signal(signal.SIGINT, handle_signal)

if __name__ == '__main__':
    main()




